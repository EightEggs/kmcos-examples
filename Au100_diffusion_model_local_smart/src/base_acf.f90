!  This file was generated by kmcos (kinetic Monte Carlo of Systems)
!  written by Andreas Garhammer (C) 2015-2016.
!
!  This file is part of kmcos.
!
!  kmcos is free software; you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation; either version 2 of the License, or
!  (at your option) any later version.
!
!  kmcos is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with kmcos; if not, write to the Free Software
!  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
!  USA
!****h* kmcos/base_acf
! FUNCTION
!    Implements the tracking process for particles of a defined species (tracked species)
!    in the case of  diffusion processes (which particle is on which site after a kMC step). 
!    Using this module each site can be specified with a property
!    and one can calculate the autocorrelation function (Integral(g(0)g(t)dt)) between 
!    a porperty at time zero (g(0)) and properties at later times (g(t)).
!    The autocorrelation function in this module is a average over all particles
!    of the tracked species.
!    Furthermore one can record the displacement for every particle of the tracked species
!    and calculate the mean squared displacement as a average over all these particles.
!    Additionally, it is possible to record the trajectory for every particle of the
!    tracked species (save for every step and every particle the site index).
!   
!    The feature acf in kmcos works for the following cases: 
!    
!    * Sampling of the autocorrelation function (ACF):
!      It is possible to sample the ACF for one species (tracked species).
!      The number of particles of this species can be constant or can change
!      (source and drain processes) during the simulation. Particles of other species
!      can also move, but the number of these particles has to be constant during the
!      simulation. Furthermore, one can record the trajectory of particles, which
!      correspond to the tracked species in the case of a constant particle number
!      during the simulation.
! 
!    * Sampling of mean squared displacement (MSD):
!      It is possible to sample the MSD for one species (tracked species).
!      The number of particles of this species has to be constant during the simulation.
!      Particles of other species can also move, but the number of these particles also
!      has to be constant during the simulation. Furthermore, one can record the trajectory
!      of particles, which correspond to the tracked species in the case of a constant 
!      particle number during the simulation.
!******


module base_acf
use kind_values
use base



!------ No implicit definition of variables !
implicit none
 

!------ A. Garhammer 2015------
integer(kind=iint), dimension(:), allocatable :: id_arr
!****v* base_acf/id_arr
! FUNCTION
!   Stores id of the particle of the tracked species, which occupies a site.
!******
!------ A. Garhammer 2016------
integer(kind=iint), dimension(:), allocatable :: site_arr
!****v* base_acf/site_arr
! FUNCTION
!   Stores site index, for every particle id of the tracked species.
!******
!------ A. Garhammer 2016------
real(kind=rdouble), dimension(:,:), allocatable :: displacement
!****v* base_acf/displacement
! FUNCTION
!   Stores the displacement for each particle of the tracked species.
!******
!------ A. Garhammer 2015------
integer(kind=iint), dimension(:), allocatable :: property_acf
!****v* base_acf/property_acf
! FUNCTION
!   Stores type_index of the corresponding property of each site.
!******
!------ A. Garhammer 2015------
integer(kind=iint), dimension(:), allocatable :: property_o
!****v* base_acf/property_o
! FUNCTION
!   Stores for each particle the initial property between two decorrelation times.
!******
!------ A. Garhammer 2016------
real(kind=rdouble), dimension(:), allocatable :: types
!****v* base_acf/types
! FUNCTION
!   Stores all possible properties.
!******
!------ A. Garhammer 2016------
real(kind=rdouble), dimension(:, :), allocatable :: product_property
!****v* base_acf/product_property
! FUNCTION
!   Stores the product of all possible combinations between two properties.
!******
!------ A. Garhammer 2015------
integer(kind=iint), dimension(:, :), allocatable :: trajectory
!****v* base_acf/trajectory
! FUNCTION
!   Stores the trajectory (site index for every kmc step) for each particle.
!******
!------ A. Garhammer 2016------
real(kind = rdouble), dimension(:), allocatable :: buffer_acf
!****v* base_acf/buffer_acf
! FUNCTION
!   Stores the product between the initial property_o and the current property for each particle
!   of the tracked species.
!******
!------ A. Garhammer 2016------
real(kind = rdouble), dimension(:), allocatable :: config_bin
!****v* base_acf/config_bin
! FUNCTION
!   Stores the property average over all particles and all wraps for every bin.
!******
!------ A. Garhammer 2016------
integer(kind = iint), dimension(:), allocatable :: counter_write_in_bin
!****v* base_acf/counter_write_in_bin
! FUNCTION
!   Stores number of contributions to a bin.
!******
!------ A. Garhammer 2016------
integer(kind = iint) :: nr_of_types
!****v* base_acf/nr_of_types
! FUNCTION
!   Stores number of different types of porperties.
!******
!------ A. Garhammer 2015------
integer(kind = iint) :: nr_of_ions
!****v* base_acf/nr_of_ions
! FUNCTION
!   Stores the number of ions in the lattice.
!******
!------ A. Garhammer 2016------
integer(kind = iint) :: nr_of_ions_before_kmc_step_acf
!****v* base_acf/nr_of_ions_before_kmc_step_acf
! FUNCTION
!   Stores the number of ions which contributes to the ACF.
!******
!------ A. Garhammer 2016------
integer(kind = iint) :: bin_index
!****v* base_acf/bin_index
! FUNCTION
!   Index of bin which is needed for the calculation of the ACF.
!******
!------ A. Garhammer 2016------
integer(kind = iint) :: extended_nr_of_bins
!****v* base_acf/extended_nr_of_bins
! FUNCTION
!   Number of bins after the multiplication with safety factor.
!******
!------ A. Garhammer 2016------
integer(kind = iint) :: nr_of_bins
!****v* base_acf/nr_of_bins
! FUNCTION
!   Number of bins for the calculation of the ACF.
!******
!------ A. Garhammer 2016------
real(kind=rdouble) :: t_bin
!****v* base_acf/t_bin
! FUNCTION
!   Bin size in s.
!******
!------ A. Garhammer 2016------
real(kind=rdouble) :: t_f
!****v* base_acf/t_f
! FUNCTION
!   Decorrelation time of the ACF in s, which is given by the user.
!******
!------ A. Garhammer 2016------
real(kind=rdouble) :: t_o
!****v* base_acf/t_o
! FUNCTION
!  Stores the new starting time after the decorrelation of one cycle was reached.
!******
!------ A. Garhammer 2016------
real(kind=rdouble) :: wrap_count
!****v* base_acf/wrap_count
! FUNCTION
!  Number of wraps for the time average of every bin.
!******
!------ A. Garhammer 2015------
integer(kind=ilong) :: kmc_step_acf
!****v* base_acf/kmc_step_acf
! FUNCTION
!   Number of kMC steps executed for the calculation of acf.
!******
!------ A. Garhammer 2015------
integer(kind=iint) :: nr_of_steps
!****v* base_acf/nr_of_steps
! FUNCTION
!   Number of kMC steps for which the trajectory is recorded.
!******
!------ A. Garhammer 2016------
real(kind=rdouble) :: nr_of_annhilations
!****v* base_acf/nr_of_annhilations
! FUNCTION
!   Number of annhilations.
!******


!****************
contains
!****************

!------ A. Garhammer 2015------
subroutine calc_nr_of_ions(trace_species)
!****f* base_acf/calc_nr_of_ions
! FUNCTION
!    Calculates the number of ions of the tracked species.
!
! ARGUMENTS
!
!    * ``trace_species`` positive integer number that represents the species which is tracked.
!******
!---------------I/O variables---------------
integer(kind = iint) :: k, species, volume
integer(kind = iint), intent(in) :: trace_species

nr_of_ions = 0

call get_volume(volume)

do k = 1, volume
  species = get_species(k)
if( species == trace_species )then
nr_of_ions = nr_of_ions + 1
endif
enddo
 
end subroutine calc_nr_of_ions

subroutine update_nr_of_ions_before_kmc_step_acf()
!****f* base_acf/update_nr_of_ions_before_kmc_step_acf
! FUNCTION
!    
! ARGUMENTS
!    * ``none``   
!******
!---------------I/O variables---------------

nr_of_ions_before_kmc_step_acf = nr_of_ions
 
end subroutine update_nr_of_ions_before_kmc_step_acf

!------ A. Garhammer 2015------
subroutine get_nr_of_ions(return_nr_of_ions)
!****f* base_acf/get_nr_of_ions
! FUNCTION
!    Returns current number of ions of the tracked_species as iint integer as defined in kind_values.f90.
!
! ARGUMENTS
!
!    * ``return_nr_of_ions`` writeable integer, where the nr_of_ions will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(out) :: return_nr_of_ions
 
return_nr_of_ions = nr_of_ions

end subroutine get_nr_of_ions
 
!------ A. Garhammer 2015------
subroutine initialize_acf(trace_species)
!****f* base_acf/initialize_acf
! FUNCTION
!    initialize_acf allocates and initializes the arrays for calculating the autocorrelation function (ACF).
!    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
!    The user have to call this subroutine, before the kmc run can start to calculate the ACF
!
! ARGUMENTS
!
!    * ``trace_species`` positive integer number that represents the species which is tracked.
!******
!---------------I/O variables---------------
integer(kind = iint) :: k, i, volume, species
integer(kind = iint), intent(in) :: trace_species

!Calculation of the number of ions
call calc_nr_of_ions(trace_species)
nr_of_ions_before_kmc_step_acf = nr_of_ions

!allocates the arrays for the autocorrelationfunction and initialize with 0
call get_volume(volume)
 
!Start initialization process for id_arr and trajectory
i = 1
do k = 1, volume
  species = get_species(k)
if( species == trace_species )then
id_arr(k) = i
site_arr(i) = k
i = i + 1
else
id_arr(k) = 0
endif
enddo

call update_property_and_buffer_acf()
 
end subroutine initialize_acf

!------ A. Garhammer 2016------
subroutine initialize_mean_squared_displacement(trace_species)
!****f* base_acf/initialize_mean_squared_displacement
! FUNCTION
!    initialize_mean_squared_displacement allocates and initializes the arrays for calculating the mean squared displacement.
!    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
!    The user must specify the species to be used for calculating the mean squared displacement.
!    The arrays start from index zero not from one. 
!    In the case of diffusion processes of other species than the tracked species, one need dummy entries at index zero.
!    These entries remain zero all the time with exception of the entry of the array displacement at index zero. In this
!    entry, the displacment of the particles of other species than the tracked species will be stored.
!    Otherwise the tracking of the particles doesn't work in this case.
!
! ARGUMENTS
!
!    * ``trace_species`` positive integer number that represents the species which is tracked.
!******
!---------------I/O variables---------------
integer(kind = iint) :: k, i, volume, species
integer(kind = iint), intent(in) :: trace_species

!Calculation of the number of ions
call calc_nr_of_ions(trace_species)
call get_volume(volume)
 
allocate(id_arr(0:volume))
id_arr = 0

allocate(site_arr(0:volume))
site_arr = 0

allocate(displacement(0:nr_of_ions, 3))
displacement = 0

!Start initialization process for id_arr
i = 1
do k = 1, volume
   species = get_species(k)
if( species == trace_species )then
id_arr(k) = i
site_arr(i) = k
i = i + 1
else
id_arr(k) = 0
endif
enddo

end subroutine initialize_mean_squared_displacement
 
!------ A. Garhammer 2016------
subroutine get_displacement(particle_id,return_displacement)
!****f* base_acf/get_displacement
! FUNCTION
!    Returns displacement for a particle of the tracked species.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of a particle. 
!    * ``return_displacement`` writeable 3 dimensonal array, where the displacement of a particle will be stored.
!******
!---------------I/O variables--------------- 
integer(kind=iint), intent(in) :: particle_id
real(kind=rdouble), dimension(3),  intent(out) :: return_displacement

return_displacement = displacement(particle_id,:)

end subroutine get_displacement

!------ A. Garhammer 2015------
subroutine allocate_tracing_arr(nr_of_types_arg)
!****f* base_acf/allocate_tracing_arr
! FUNCTION
!    Allocates the arrays for the calculation of the ACF.
!    The most arrays start from index zero not from one. 
!    In the cases of drain and source processes of the tracked species
!    and diffusion processes of other species, one need dummy entries in the arrays at index zero.
!    These entries remain zero all the time.
!    Otherwise the tracking of the particles doesn't work in these cases.
!
! ARGUMENTS
!
!    * ``nr_of_types_arg`` positive integer that represents the number of different types of properties
!******
!---------------I/O variables--------------- 
integer(kind = iint), intent(in) :: nr_of_types_arg
integer(kind = iint) :: volume

call get_volume(volume)
nr_of_types = nr_of_types_arg

allocate(types(nr_of_types))
types = 0

allocate(property_acf(0:volume))
property_acf = 0

allocate(property_o(0:volume))
property_o = 0

allocate(product_property(0:nr_of_types,0:nr_of_types))
product_property = 0

allocate(id_arr(0:volume))
id_arr = 0

allocate(site_arr(0:volume))
site_arr = 0

allocate(buffer_acf(0:volume))
buffer_acf = 0
 
end subroutine allocate_tracing_arr

!------ A. Garhammer 2016------
subroutine allocate_trajectory(nr_of_steps_arg)
!****f* base_acf/allocate_trajectory
! FUNCTION
!    Allocates and intializes the trajecotry array.
!    The array trajectory starts from index zero.
!    In the case of diffusion processes of other species than the tracked species, 
!    one need a dummy entry of the value zero at index zero to record the trajectory.
!    This dummy entry at index zero remains zero all the time.
!    Otherwise the record doesn't work.
!
! ARGUMENTS
!
!    * ``nr_of_steps_arg``, postive integer that represents the number of kMC steps,
!      for which the trajectory is recorded.
!******
!---------------I/O variables---------------
integer(kind = iint), intent(in) :: nr_of_steps_arg
integer(kind = iint) :: i

nr_of_steps = nr_of_steps_arg 

allocate(trajectory(0:nr_of_ions, nr_of_steps + 1))
trajectory = 0

do i = 1 , nr_of_ions
trajectory(i,1) = site_arr(i)
enddo

kmc_step_acf = 0

end subroutine allocate_trajectory

!------ A. Garhammer 2016------
subroutine allocate_config_bin_acf(t_bin_arg,t_f_arg,safety_factor_t_f_arg,extending_factor_arg)
!****f* base_acf/allocate_config_bin_acf
! FUNCTION
!    allocate_config_bin_acf allocates and initializes the arrays and the variables for the on the fly
!    calculation of the autocorrelation function (ACF).
!    The user must specify the bin size t_bin and the decorrelation time t_f to be used for calculating the ACF.
!    From this, the number of bins is calculated.
!    If the number of trash bins is too small and the time interval, which exceeds t_f too big, a segmentation fault occurs.
!    This problem can be fixed by increasing the number of trash bin with extending_factor and starting the sampling of ACF again.
!
! ARGUMENTS
!
!    * ``t_bin_arg`` real representing the bin size.
!    * ``t_f_arg`` real representing the decorrelation time.
!    * ``safety_factor_t_f_arg`` positive integer that extends t_f
!    * ``extending_factor_arg`` positive integer that extends the nr of bins
!******
!---------------I/O variables---------------
real(kind = rdouble), intent(in) :: t_bin_arg
real(kind = rdouble), intent(in) :: t_f_arg
integer(kind = iint), intent(in), optional :: safety_factor_t_f_arg, extending_factor_arg
integer(kind = iint) :: safety_factor_t_f, extending_factor
real(kind = rdouble) :: kmc_time

call get_kmc_time(kmc_time)
 
if(.not. present(safety_factor_t_f_arg) .or. safety_factor_t_f_arg.eq.0)then
safety_factor_t_f = 2
else
safety_factor_t_f = safety_factor_t_f_arg
end if

if(.not. present(extending_factor_arg) .or. extending_factor_arg.eq.0)then
extending_factor = 2
else
extending_factor = extending_factor_arg
end if
t_f = t_f_arg * safety_factor_t_f
t_bin = t_bin_arg
nr_of_bins = int(t_f/t_bin + 1)
extended_nr_of_bins = nr_of_bins * extending_factor
t_f = nr_of_bins * t_bin
allocate(config_bin(extended_nr_of_bins))
config_bin = 0
allocate(counter_write_in_bin(extended_nr_of_bins))
counter_write_in_bin = 0
bin_index = 0
wrap_count = 0
nr_of_annhilations = 0
t_o = kmc_time

print *, "+------------------------------------------------------------+"
print *, "|Decorrelation time|", t_f, "s"
print *, "+------------------------------------------------------------+"
print *, "|Number of bins for ACF|", nr_of_bins
print *, "+------------------------------------------------------------+"
print *, "|Total number of bins|", extended_nr_of_bins
print *, "+------------------------------------------------------------+"
print *, "|Safety factor decorrelation time|", safety_factor_t_f
print *, "+------------------------------------------------------------+"
print *, "|Extending factor number of bins|", extending_factor
print *, "+------------------------------------------------------------+"

end subroutine allocate_config_bin_acf

!------ A. Garhammer 2016------
subroutine set_acf_to_zero()
!****f* base_acf/set_acf_to_zero
! FUNCTION
!    Sets all acf arrays and parameters to initial state.
!    After this, the sampling of the ACF can start from new.
!
! ARGUMENTS
!
!    * ``none``.
!******
!---------------I/O variables---------------
real(kind = rdouble) :: kmc_time

call get_kmc_time(kmc_time)
call update_nr_of_ions_before_kmc_step_acf() 
call update_property_and_buffer_acf()  

config_bin = 0
counter_write_in_bin = 0
bin_index = 0
wrap_count = 0
nr_of_annhilations = 0
t_o = kmc_time

end subroutine set_acf_to_zero

!------ A. Garhammer 2016------
subroutine set_displacement_to_zero()
!****f* base_acf/set_displacement_to_zero
! FUNCTION
!    Sets displacement vector to zero.
!    After this, the recording of the displacement can start
!    from new.
!
! ARGUMENTS
!
!    * ``none``.
!******
!---------------I/O variables---------------

displacement = 0

end subroutine set_displacement_to_zero

!------ A. Garhammer 2016------
subroutine get_config_bin_acf(bin_index,return_config_bin)
!****f* base_acf/get_config_bin_acf
! FUNCTION
!    Returns an entry of the array config_bin.
!
! ARGUMENTS
!
!    * ``bin_index`` positive integer that represents the bin index.
!    * ``return_config_bin`` writeable real, in which the entry of a bin is stored .
!******
!---------------I/O variables--------------- 
integer(kind=iint), intent(in) :: bin_index
real(kind=rdouble), intent(out) :: return_config_bin
 
return_config_bin = config_bin(bin_index)

end subroutine get_config_bin_acf

!------ A. Garhammer 2016------
subroutine get_counter_write_in_bin(bin_index,return_counter_write_in_bin)
!****f* base_acf/get_counter_write_in_bin
! FUNCTION
!    Returns an entry of the array counter_write_in_bin.
!
! ARGUMENTS
!
!    * ``bin_index`` positive integer that represents the bin index.
!    * ``return_counter_write_in_bin`` writeable integer, in which the number contributions of one bin is stored .
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: bin_index
real(kind=rdouble), intent(out) :: return_counter_write_in_bin
 
return_counter_write_in_bin = counter_write_in_bin(bin_index)

end subroutine get_counter_write_in_bin 

!------ A. Garhammer 2015------
subroutine set_property_acf(site_nr_acf,input_property_acf)
!****f* base_acf/set_property_acf
! FUNCTION
!    set_property_acf sets the property of each site for the calculation of ACF.
!    The type index of the corresponding property will be stored in property_acf.
!
! ARGUMENTS
!
!    * ``site_nr_acf`` positive integer that represents the site indx.
!    * ``input_property_acf`` real that represents the type index of the corresponding property .
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: site_nr_acf
integer(kind=iint), intent(in) :: input_property_acf
 
property_acf(site_nr_acf) = input_property_acf

end subroutine set_property_acf

!------ A. Garhammer 2015------
subroutine set_types(type_index,input_property)
!****f* base_acf/set_types
! FUNCTION
!    set_types sets all possible properties.
!    The properties will be stored in types.
!    The properties are defined by the user.
!
! ARGUMENTS
!
!    * ``type_index`` positive integer that represents the type index for a property.
!    * ``input_property`` real that represents the property.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: type_index
real(kind=rdouble), intent(in) :: input_property

types(type_index) = input_property

end subroutine set_types
 
!------ A. Garhammer 2016------
subroutine set_product_property(type_index_o,type_index,input_product_property)
!****f* base_acf/set_product_property
! FUNCTION
!    set_product_property sets all possible combination of products of properties.
!
! ARGUMENTS
!
!    * ``type_index_o`` positive integer that represents the type index of the initial property.
!    * ``type_index`` positve integer that represents the type index of a property.
!    * ``input_product_property`` real that represents the product of two properties.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: type_index_o
integer(kind=iint), intent(in) :: type_index
real(kind=rdouble), intent(in) :: input_product_property

product_property(type_index_o,type_index) = input_product_property

end subroutine set_product_property

!------ A. Garhammer 2015------
subroutine get_property_acf(site,return_property_acf)
!****f* base_acf/get_property_acf
! FUNCTION
!    Returns an entry of the array property_acf.
!
! ARGUMENTS
!
!    * ``site`` positive integer that represents the site index.
!    * ``return_property_acf`` writeable integer, where an entry of property_acf will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: site
integer(kind=iint), intent(out) :: return_property_acf

return_property_acf = property_acf(site)

end subroutine get_property_acf

!------ A. Garhammer 2016------
subroutine get_types(type_index,return_types)
!****f* base_acf/get_types
! FUNCTION
!    Returns an entry of the array types.
!
! ARGUMENTS
!
!    * ``type_index`` positive integer that represents the type index.
!    * ``return_types`` writeable real, where the property of the corresponding type index will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: type_index
real(kind=rdouble), intent(out) :: return_types

return_types = types(type_index)
 
end subroutine get_types

!------ A. Garhammer 2016------
subroutine get_product_property(type_index_o,type_index,return_product_property)
!****f* base_acf/get_product_property
! FUNCTION
!    Returns an entry of the array product_property.
!
! ARGUMENTS
!
!    * ``type_index_o`` positive integer that represents the type index of the initial property.
!    * ``type_index`` positve integer that represents the type index of a property.   
!    * ``return_product_property`` writeable real, where an entry of product_property will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: type_index_o, type_index
real(kind=rdouble), intent(out) :: return_product_property
 
return_product_property = product_property(type_index_o,type_index)

end subroutine get_product_property

!------ A. Garhammer 2016------
subroutine get_property_o(particle_id,return_property_o)
!****f* base_acf/get_property_o
! FUNCTION
!    Returns an entry of the array property_o.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents id of a particle. 
!    * ``return_property_o`` writeable real, where an entry of property_o will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: particle_id
integer(kind=iint), intent(out) :: return_property_o

return_property_o = property_o(particle_id)

end subroutine get_property_o

!------ A. Garhammer 2016------
subroutine get_buffer_acf(particle_id,return_buffer_acf)
!****f* base_acf/get_buffer_acf
! FUNCTION
!    Returns an entry of the array buffer_acf.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents id of a particle.
!    * ``return_buffer_acf`` writeable real, where an entry of buffer_acf will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: particle_id 
real(kind=rdouble), intent(out) :: return_buffer_acf

return_buffer_acf = buffer_acf(particle_id)

end subroutine get_buffer_acf

!------ A. Garhammer 2015------
subroutine get_id_arr(site,return_id_arr)
!****f* base_acf/get_id_arr
! FUNCTION
!    Returns an entry of the array id_arr.
!
! ARGUMENTS
!
!    * ``site`` positive integer that represents the site index.
!    * ``return_id_arr`` writeable integer, where an entry of id_arr will be stored.
!******
!---------------I/O variables--------------- 
integer(kind=iint), intent(in) :: site
integer(kind=iint), intent(out) :: return_id_arr

return_id_arr = id_arr(site)

end subroutine get_id_arr

!------ A. Garhammer 2016------
subroutine get_site_arr(particle_id,return_site_arr)
!****f* base_acf/get_site_arr
! FUNCTION
!    Returns an entry of the array site_arr.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of a particle.
!    * ``return_site_arr`` writeable integer, where an entry of site_arr will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: particle_id 
integer(kind=iint), intent(out) :: return_site_arr

return_site_arr = site_arr(particle_id)

end subroutine get_site_arr

!------ A. Garhammer 2015------
subroutine get_trajectory(particle_id,kmc_step,return_trajectory)
!****f* base_acf/get_trajectory
! FUNCTION
!    Returns an entry of the array trajectory.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of a particle.
!    * ``kmc_step`` positive integer that represents the number of kMC steps.
!    * ``return_trajectory`` writeable integer, where an entry of trajectory  will be stored.
!******
!---------------I/O variables---------------
integer(kind=iint), intent(in) :: particle_id,kmc_step
integer(kind=iint), intent(out) :: return_trajectory

return_trajectory = trajectory(particle_id,kmc_step)

end subroutine get_trajectory

!------ A. Garhammer 2015------
subroutine update_trajectory(particle_id, kmc_step_acf)
!****f* base/update_trajectory
! FUNCTION
!    update_trajectory saves for each particle the site index after one kmc step.
!    This function is optional and can be turned on and off.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of the jumping particle.
!    * ``kmc_step_acf`` positive integer that represents the number of kMC steps which were executed
!        for the recording of the trajectory.
!******
!---------------I/O variables---------------
integer(kind = iint), intent(in) :: particle_id
integer(kind = ilong), intent(in) :: kmc_step_acf
 
trajectory(:,kmc_step_acf+1) = trajectory(:,kmc_step_acf)
trajectory(particle_id,kmc_step_acf+1) = site_arr(particle_id)

end subroutine update_trajectory
 
!------ A. Garhammer 2015------
subroutine assign_particle_id(init_site,particle_id)
!****f* base_acf/assign_particle_id
! FUNCTION
!    assign_particle_id gives the id of the jumping particle in one kmc step.
!    In the case of an exit process of the particle with the highest id,
!    the output for particle_id is zero. Also for a hop of a particle of  
!    other species than the tracked species. Therefore, the arrays for the 
!    tracking process and for the sampling of ACF or MSD start with index zero.
!    The entries at this index are dummy values.   
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of the jumping particle.
!    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
!        before a process happens.
!******
!---------------I/O variables---------------
integer(kind = iint) :: k
integer(kind = iint), intent(out) :: particle_id
integer(kind = iint), intent(in) :: init_site

particle_id = id_arr(init_site)

end subroutine assign_particle_id

!------ A. Garhammer 2016------
subroutine update_displacement(particle_id,displace_coord)
!****f* base_acf/update_displacement
! FUNCTION
!    update_displacement updates the displacement of the jumping particle in one kmc step.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of the jumping particle.
!    * ``displace_coord`` 3 dimensonal array, where the displacement of the jumping particle will be stored.
!******
!---------------I/O variables---------------
integer(kind = iint), intent(in) :: particle_id
real(kind = rdouble), dimension(3), intent(in) :: displace_coord
 
displacement(particle_id,:) = displacement(particle_id,:) + displace_coord

end subroutine update_displacement

!------ A. Garhammer 2016------
subroutine calc_mean_squared_disp(mean_squared_disp)
!****f* base_acf/calc_mean_squared_disp
! FUNCTION
!   calc_mean_squared_disp calculates the mean squared displacement after a kmc run.
!   The user have to call this subroutine after the kmc run, to get the mean squared displacement.
!
! ARGUMENTS
!
!    * ``mean_squared_disp`` writeable real, where the mean squared displacement will be stored.
!******
!---------------I/O variables--------------- 
integer(kind = iint) :: k
real(kind = rdouble), intent(out) :: mean_squared_disp

mean_squared_disp = 0
k = 1
do k = 1, nr_of_ions
mean_squared_disp = mean_squared_disp + sum(displacement(k,:)**2)
enddo

mean_squared_disp = mean_squared_disp / nr_of_ions

end subroutine calc_mean_squared_disp

!------ A. Garhammer 2016------
subroutine calc_acf(bin_index,return_acf)
!****f* base_acf/calc_acf
! FUNCTION
!   calc_acf calculates ACF after a kmc run.
!   The user have to call this subroutine after the kmc run, to get the ACF.
!
! ARGUMENTS
!
!    * ``bin_index`` positive integer that represents the bin index.
!    * ``return_acf`` writeable real, where an entry of the ACF will be stored.
!******
!---------------I/O variables--------------- 
integer(kind=iint), intent(in) :: bin_index
real(kind = rdouble), intent(out) :: return_acf
 
return_acf = config_bin(bin_index)/(wrap_count*t_bin)

end subroutine calc_acf

!------ A. Garhammer 2015------
subroutine update_id_arr(particle_id,init_site,fin_site)
!****f* base_acf/update_id_arr
! FUNCTION
!    update_id_arr updates id_arr after one kmc step.
!    The id of the jumping particle is stored in the entry of the id_arr 
!    which corresponds to the site index, which is occupied by this particle after the jump.
!    The entry of the id_arr, which corresponds to the site index,
!    which is occupied by this particle before the jump, is setted to zero.
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of the jumping particle.
!    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
!        before a process happens.
!    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
!        after a process.
!******
!---------------I/O variables--------------- 
integer(kind = iint), intent(in) :: particle_id
integer(kind = iint), intent(in) :: fin_site
integer(kind = iint), intent(in) :: init_site

id_arr(init_site) = 0
id_arr(fin_site) = particle_id
site_arr(particle_id) = fin_site
site_arr(0) = 0

end subroutine update_id_arr

!------ A. Garhammer 2016------
subroutine drain_process(exit_site, init_site, fin_site)
!****f* base_acf/drain_process
! FUNCTION
!    drain_process updates the arrays for the tracking process and for the sampling of the autocorrelation function (ACF) as follows:
!    In the case of an exit process (a particle leaves the system), the entries of the arrays which correspond to the particle
!    which leaves the system are replaced by the entries of the particle with the highest id (the particle with the highest id becomes
!    the id of the particle which exits the system). If a particle exits the system with an id that is smaller than the highest id
!    in the system, the output for init_site and fin_site is the site index that corresponds to the site which is occupied by the particle 
!    with the highest id and the tracking process works as usual. The tracking process updates the entries of the arrays which correspond to 
!    to this particle with the same values as before.
!    If the particle with the highest id exits the system, the output of init_site and fin_site is zero. In this case the tracking process 
!    updates the entries for the particle with id zero, which doesn't exist. This is the reason why the arrays for the tracking process
!    and for the sampling of the ACF have to start with index zero. The value for these entries at index zero is always zero.
!    Furthermore, the real number of ions (nr_of_ions) which correspond to the tracked species has to be updated and also the number of ions 
!    (nr_of_ions_before_kmc_step_acf) which contribute to the ACF. If a particle enters the system within the decorrelation time, this particle 
!    doesn't contribute to the ACF. It contributes only after a wrap (decorrelation time was reached), if the particle is still in the system.       
!    Nevertheless, if a particle enters the system within the decorrelation time, it will be tracked, but the entry for this particle in the array
!    property_o is zero. Therefore, it has no contribution to the ACF and nr_of_ions_before_kmc_step_acf has the same value as before the kMC step. 
!          
! ARGUMENTS
!
!    * ``exit_site`` positive integer that represents the index of the site from which the particle is taken.
!    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
!        before a process happens.
!    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
!        after a process.
!******
!---------------I/O variables--------------- 
integer(kind = iint) :: particle_id
integer(kind = iint), intent(in) :: exit_site
integer(kind = iint), intent(out) :: init_site, fin_site

particle_id = id_arr(exit_site)
site_arr(particle_id) = site_arr(nr_of_ions)
 
id_arr(site_arr(particle_id)) = particle_id
site_arr(nr_of_ions) = 0
id_arr(exit_site) = 0
if( property_o(particle_id).ne.0 )then
   nr_of_ions_before_kmc_step_acf = nr_of_ions_before_kmc_step_acf - 1 
endif
property_o(particle_id) = property_o(nr_of_ions)
property_o(nr_of_ions) = 0
init_site = site_arr(particle_id)
fin_site = site_arr(particle_id)
buffer_acf(particle_id) = buffer_acf(nr_of_ions)
buffer_acf(nr_of_ions) = 0
nr_of_ions = nr_of_ions - 1
nr_of_annhilations = nr_of_annhilations + 1

end subroutine drain_process

!------ A. Garhammer 2016------
subroutine source_process(entry_site, init_site, fin_site)
!****f* base_acf/source_process
! FUNCTION
!    source_process updates the arrays for the tracking process and for the sampling of the autocorrelation function (ACF) as follows:
!    In the case of an entry process (a particle enters the system), the particle which enters the system becomes the particle with the
!    highest id in the system.
!    Furthermore, the real number of ions (nr_of_ions) which correspond to the tracked species has to be updated. If a particle enters
!    the system within the decorrelation time, this particle doesn't contribute to the ACF. It contributes only after a wrap
!    (decorrelation time was reached), if the particle is still in the system.       
!    Nevertheless, if a particle enters the system within the decorrelation time, it will be tracked, but the entry for this particle in the array
!    property_o is zero. Therefore, it has no contribution to the ACF and nr_of_ions_before_kmc_step_acf has the same value as before the kMC step.
!
! ARGUMENTS
!
!    * ``entry_site`` positive integer that represents the index of the site on which the particle is put.
!    * ``init_site`` positive integer that represents the index of the site, which is occupied by the particle
!        before a process happens.
!    * ``fin_site`` positive integer that represents the index of the site, which is occupied by the particle
!        after a process.
!******
!---------------I/O variables--------------- 
integer(kind = iint), intent(in) :: entry_site
integer(kind = iint), intent(out) :: init_site, fin_site
 
nr_of_ions = nr_of_ions + 1
id_arr(entry_site) = nr_of_ions
site_arr(nr_of_ions) = entry_site
fin_site = entry_site
init_site = entry_site

end subroutine source_process

!------ A. Garhammer 2016------
subroutine update_buffer_acf(particle_id)
!****f* base_acf/update_buffer_acf
! FUNCTION
!    update_buffer_acf updates the buffer_acf array. This array contains for each particle id of the tracked species the current product (g(0)g(t))
!    of the property_o (g(0)) and the current property (g(t)). For an id that doesn't contribute to the ACF (entry of a particle within the
!    decorrelation time) the entry at this index (id) is zero. In the case of an exit process of the particle with the highest id or a hop of
!    other species than the tracked species, the dummy entry (value zero) at index zero of the array buffer_acf is used. Because the particle id
!    has the value zero in these cases. Also, the arrays product_property, property_o, property_acf and site_arr need a dummy entry of value zero
!    at index zero.    
!
! ARGUMENTS
!
!    * ``particle_id`` positive integer that represents the id of the jumping particle.
!******
!---------------I/O variables--------------- 
integer(kind = iint), intent(in) :: particle_id

buffer_acf(particle_id) = product_property(property_o(particle_id),property_acf(site_arr(particle_id)))
 
end subroutine update_buffer_acf

!------ A. Garhammer 2016------
subroutine update_property_and_buffer_acf()
!****f* base_acf/update_property_and_buffer_acf
! FUNCTION
!    update_property_and_buffer_acf initializes the arrays propert_o and buffer_acf in the beginning
!    of ACF sampling and after a wrap (correlation time t_f was reached).
!
! ARGUMENTS
!
!    * ``none``
!******
!---------------I/O variables---------------
integer(kind = iint) :: i, volume

call get_volume(volume)

do i = 1, volume
property_o(i) = property_acf(site_arr(i))
buffer_acf(i) = product_property(property_o(i),property_o(i))
enddo

end subroutine update_property_and_buffer_acf

!------ A. Garhammer 2016------
subroutine update_config_bin()
!****f* base_acf/update_config_bin
! FUNCTION
!    update_config_bin updates the config_bin and the counter_write_in_bin arrays as follows:
!    The timeline is divided into bins with the size t_bin. The borders of this timeline are
!    t_o (start time for ACF sampling of one wrap) and t_f (decorrelation time of one wrap).
!    The number of bins is calculated by int((t_f/t_o)+1) and the bin_index starts at zero.
!    After a kMC step was executed, a exponentially distributed time interval was generated
!    and was added to the kmc_time. update_config_bin checks which bins correspond to this
!    new time and stores the corresponding entries (g(0)g(t)) to the right bins.
!    These entries depend on the last configuration of the system. A entry of a bin is
!    calculated by the sum of the buffer_acf array and by the division of this sum by the
!    number of ions which contribute to the ACF within one decorrelation time t_f (one wrap).
!    For a correct evaluation of the integral of the ACF, a entry of a bin has to be weighted
!    by the right fraction of the bin size. 
!    To avoid too many if conditions, the config_bin array has more than int((t_f/t_o)+1)
!    bins. These additonal bins are trash bins and don't have a meaning for the ACF. 
!    If the kmc_time exceeds the decorrelation time t_f, the binning process uses the whole
!    time interval, which was generated by the corresponding kMC step. Therefore, the trash
!    bins are needed. If the number of trash bins is too small and the time interval,
!    which exceeds t_f too big, a segmentation fault occurs. This problem can be fixed by
!    increasing the number of trash bin with extending_factor in allocate_config_bin_acf
!    and starting the sampling of ACF again.  
!    After the exeedance of t_f, the new start time t_o is equal to the current kmc_time and
!    also the intial configuration is the configuration at this kmc_time, which exceeds t_f.
!    The bin index is set to zero, the property_o array is updated and the binning process
!    starts again. To get a good statistic, it is necessary to have a lot of wraps. In the
!    case of entry and exit processes, the number of annhilations (particle exit the system)
!    should be significantly smaller than the number of wraps. Otherwise too few particles 
!    contribute to the ACF and the statistic will be bad.
!    Furthermore, the number of contributions for each bin is saved in the array
!    config_write_in_bin.   
!    
!
! ARGUMENTS
!
!    * ``none``
!******
!---------------I/O variables---------------
real(kind = rdouble) :: entry_bin, kmc_time, kmc_time_step

call get_kmc_time(kmc_time)
call get_kmc_time_step(kmc_time_step)

entry_bin = sum(buffer_acf)
if(entry_bin.eq.0)then
entry_bin = 0
else
entry_bin = entry_bin/nr_of_ions_before_kmc_step_acf
endif
 
if(kmc_time - t_o < (bin_index + 1) * t_bin)then
config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * kmc_time_step
counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
else

config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * ((bin_index + 1) * t_bin - (kmc_time - t_o - kmc_time_step))
counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
bin_index = bin_index + 1
if(bin_index < nr_of_bins)then
do while((bin_index + 1) * t_bin < kmc_time - t_o)

config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * t_bin
counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
bin_index = bin_index + 1

enddo

config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * (kmc_time - t_o - (bin_index * t_bin))
counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1

end if
end if

end subroutine update_config_bin

subroutine update_after_wrap_acf()
!****f* base_acf/update_after_wrap_acf
! FUNCTION
!    update_after_wrap_acf checks if the current kmc_time exceeds the decorrelation time t_f.
!    If this is the case, the bin index is set to zero, t_o is set to the current kmc_time,
!    the number of wraps is increased by one and the number of ions, which contribute to the ACF
!    is updated with the new intial configuration. Also, the property_o and the buffer_acf arrays  
!    are updated with the new inital configuration. 
!    After this, a new wrap starts.
! ARGUMENTS
!
!    * ``none``
!******
!---------------I/O variables--------------- 
real(kind = rdouble) :: kmc_time

call get_kmc_time(kmc_time)

if(bin_index > nr_of_bins - 1)then
t_o = kmc_time
bin_index = 0
wrap_count = wrap_count + 1
call update_property_and_buffer_acf()
call update_nr_of_ions_before_kmc_step_acf()
end if

end subroutine update_after_wrap_acf 

!------ A. Garhammer 2015------
subroutine update_kmc_step_acf()
!****f* base_acf/update_kmc_step_acf
! FUNCTION
!    Updates kmc_step_acf.
!
! ARGUMENTS
!
!    * ``none``
!******
!---------------I/O variables---------------

kmc_step_acf = kmc_step_acf + 1

end subroutine update_kmc_step_acf

!------ A. Garhammer 2015------
subroutine get_kmc_step_acf(return_kmc_step_acf)
!****f* base_acf/get_kmc_step_acf
! FUNCTION
!    Return the current kmc_step_acf
!
! ARGUMENTS
!
!    * ``return_kmc_step_acf`` Writeable integer
!******
!---------------I/O variables---------------
integer(kind=ilong), intent(out) :: return_kmc_step_acf

return_kmc_step_acf = kmc_step_acf

end subroutine get_kmc_step_acf

!------ A. Garhammer 2016------
subroutine deallocate_acf()
!****f* base_acf/deallocate_acf
! FUNCTION
!    Deallocate all allocatable arrays: id_arr, site_arr, displacement,
!    property_acf, property_o, types, product_property, trajectory,
!    buffer_acf, config_bin, counter_write_in_bin
!
! ARGUMENTS
!
!    ``none``
!******
if(allocated(id_arr))then
    deallocate(id_arr)
else
    print *,"Warning: id_arr was not allocated, tried to deallocate."
endif
if(allocated(site_arr))then
    deallocate(site_arr)
else
    print *,"Warning: site_arr was not allocated, tried to deallocate."
endif
if(allocated(displacement))then
    deallocate(displacement)
else
    print *,"Warning: displacement was not allocated, tried to deallocate."
endif
if(allocated(property_acf))then
    deallocate(property_acf)
else
    print *,"Warning: property_acf was not allocated, tried to deallocate."
endif
if(allocated(property_o))then
    deallocate(property_o)
else
    print *,"Warning: property_o was not allocated, tried to deallocate."
endif
if(allocated(types))then
    deallocate(types)
else
    print *,"Warning: types was not allocated, tried to deallocate."
endif
if(allocated(product_property))then
    deallocate(product_property)
else
    print *,"Warning: product_property was not allocated, tried to deallocate."
endif
if(allocated(trajectory))then
    deallocate(trajectory)
else
    print *,"Warning: trajectory was not allocated, tried to deallocate."
endif
if(allocated(buffer_acf))then
    deallocate(buffer_acf)
else
    print *,"Warning: buffer_acf was not allocated, tried to deallocate."
endif
if(allocated(config_bin))then
    deallocate(config_bin)
else
    print *,"Warning: config_bin was not allocated, tried to deallocate."
endif
if(allocated(counter_write_in_bin))then
    deallocate(counter_write_in_bin)
else
    print *,"Warning: counter_write_in_bin was not allocated, tried to deallocate."
endif

end subroutine deallocate_acf


end module base_acf
